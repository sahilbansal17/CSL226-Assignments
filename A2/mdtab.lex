structure T = Tokens 
 
(* ML-Lex requires these types and values to be defined *) 
type pos = int 
type svalue = T.svalue 
type ('a,'b) token = ('a, 'b) T.token 
type lexresult = (svalue, pos) token
val eof = (fn () => T.EOF)
 
val error = fn x => TextIO.output(TextIO.stdOut,x ^ "\n")

(* to use yypos, need to pass starting argument in makeLexer *)
(* to use Tokens from ML-Yacc, need to define header with functor having structure generated by yacc as argument *)

%%
%posarg 
%header (functor mdtabLexFun(structure Tokens : mdtab_TOKENS));

tagName = [A-Za-z]+;
ws = [\ \t];

%%

\n                          => (continue());
{ws}+                       => (continue());

"<"                         => (T.START_TAG_BEG(yypos));
"<"{ws}*"/"                 => (T.END_TAG_BEG(yypos));

{tagName}                   => (T.TAG_NAME(yytext, yypos));

">"                         => (T.TAG_END(yypos));

[^\<>*_]*             => (T.HTML_CONTENT(yytext, yypos));

"*"                         => (T.ITALICS(yypos));
"**"                        => (T.BOLD(yypos));
"_"                         => (T.UNDERLINE(yypos));
"#"                         => (T.H1(yypos));
"##"                        => (T.H2(yypos));
"###"                       => (T.H3(yypos));
"####"                      => (T.H4(yypos));
"#####"                     => (T.H5(yypos));
"######"                    => (T.H6(yypos));
.                           => (error("ignoring bad character:"^yytext); T.EOF);